<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.85.0" />


<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico" />



<title>Caffeine缓存简单介绍 - 码农熊猫</title>


<meta name="author" content="码农熊猫" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="Java, Caching" />


<meta property="og:title" content="Caffeine缓存简单介绍" />
<meta name="twitter:title" content="Caffeine缓存简单介绍" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pinmost.com/post/java-caching-caffeine/" /><meta property="og:description" content="1、简介
在本文中，我们将了解Caffeine，一个用于Java的高性能缓存库。
缓存和Map之间的一个根本区别是缓存会清理存储的项目。
一个清理策略会决定在某个给定时间哪些对象应该被删除，这个策略直接影响缓存的命中率——缓存库的一个关键特性。
Caffeine使用Window TinyLfu清理策略，它提供了接近最佳的命中率。" />
<meta name="twitter:description" content="1、简介
在本文中，我们将了解Caffeine，一个用于Java的高性能缓存库。
缓存和Map之间的一个根本区别是缓存会清理存储的项目。
一个清理策略会决定在某个给定时间哪些对象应该被删除，这个策略直接影响缓存的命中率——缓存库的一个关键特性。
Caffeine使用Window TinyLfu清理策略，它提供了接近最佳的命中率。" /><meta property="og:image" content="https://pinmost.com/img/og.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://pinmost.com/img/og.png" /><meta property="article:published_time" content="2021-07-06T10:18:22+08:00" /><meta property="article:modified_time" content="2021-07-06T10:18:22+08:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://pinmost.com/assets/css/fuji.min.css" />








</head>

<body
  data-theme="auto"
  data-theme-auto='true'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://pinmost.com">码农熊猫</a>
            
            <span class="title-sub">6年业余，13年专业。空谈误国，code兴邦。</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://pinmost.com/post/java-caching-caffeine/">Caffeine缓存简单介绍</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-07-06</span>

<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;2380 字</span>

<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/java">Java</a>&nbsp;<a href="/tags/caching">Caching</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <h3 id="1简介">1、简介</h3>
<p>在本文中，我们将了解Caffeine，一个用于Java的高性能缓存库。</p>
<p>缓存和Map之间的一个根本区别是缓存会清理存储的项目。</p>
<p>一个清理策略会决定在某个给定时间哪些对象应该被删除，这个策略直接影响缓存的命中率——缓存库的一个关键特性。</p>
<p>Caffeine使用<code>Window TinyLfu</code>清理策略，它提供了接近最佳的命中率。</p>
<h3 id="2依赖">2、依赖</h3>
<p>我们需要将Caffeine依赖添加到我们的pom.xml中：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;
    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;
    &lt;version&gt;2.5.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>您可以在Maven Central上找到最新版本的Caffeine。</p>
<h3 id="3写入缓存">3、写入缓存</h3>
<p>让我们关注Caffeine的三种缓存写入策略：手动、同步加载和异步加载。</p>
<p>首先，让我们编写一个类，作为要存储在缓存中的值的类型：</p>
<pre><code class="language-java">class DataObject {
    private final String data;

    private static int objectCounter = 0;
    // standard constructors/getters
    
    public static DataObject get(String data) {
        objectCounter++;
        return new DataObject(data);
    }
}
</code></pre>
<h4 id="31手动写入">3.1、手动写入</h4>
<p>在此策略中，我们手动将值写入缓存并稍后读取它们。</p>
<p>我们先初始化缓存：</p>
<pre><code class="language-java">Cache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()
  .expireAfterWrite(1, TimeUnit.MINUTES)
  .maximumSize(100)
  .build();
</code></pre>
<p>现在，我们可以使用<code>getIfPresent</code>方法从缓存中获取一些值。如果缓存中不存在该值，则此方法将返回<code>null</code>：</p>
<pre><code class="language-java">String key = &quot;A&quot;;
DataObject dataObject = cache.getIfPresent(key);

assertNull(dataObject);
</code></pre>
<p>我们可以使用<code>put</code>方法手动写入缓存：</p>
<pre><code class="language-java">cache.put(key, dataObject);
dataObject = cache.getIfPresent(key);

assertNotNull(dataObject);
</code></pre>
<p>我们还可以使用<code>get</code>方法获取值，该方法接受一个函数和一个键作为参数。如果缓存中不存在该键，则此函数将用于提供兜底值，该值将在执行后写入缓存：</p>
<pre><code class="language-java">dataObject = cache
  .get(key, k -&gt; DataObject.get(&quot;Data for A&quot;));

assertNotNull(dataObject);
assertEquals(&quot;Data for A&quot;, dataObject.getData());
</code></pre>
<p>这个GET方法执行是原子性的。这意味着即使多个线程同时请求该值，执行只会进行一次。这就是为什么使用<code>get</code>比<code>getIfPresent</code>更好。</p>
<p>有时我们需要手动使一些缓存的值失效：</p>
<pre><code class="language-java">cache.invalidate(key);
dataObject = cache.getIfPresent(key);

assertNull(dataObject);
</code></pre>
<h4 id="32同步加载">3.2、同步加载</h4>
<p>这种加载缓存的方法需要一个<code>Function</code>，用于初始化写入值，类似于手动写入策略的get方法，让我们看看如何使用它。</p>
<p>首先，我们需要初始化我们的缓存：</p>
<pre><code class="language-java">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()
  .maximumSize(100)
  .expireAfterWrite(1, TimeUnit.MINUTES)
  .build(k -&gt; DataObject.get(&quot;Data for &quot; + k));
</code></pre>
<p>现在我们可以使用<code>get</code>方法读取值：</p>
<pre><code class="language-java">DataObject dataObject = cache.get(key);

assertNotNull(dataObject);
assertEquals(&quot;Data for &quot; + key, dataObject.getData());
</code></pre>
<p>我们还可以使用<code>getAll</code>方法获取一组值：</p>
<pre><code class="language-java">Map&lt;String, DataObject&gt; dataObjectMap 
  = cache.getAll(Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));

assertEquals(3, dataObjectMap.size());
</code></pre>
<p>值从传递给<code>build</code>方法的底层后端初始化<code>Function</code>中读取到，这样就可以使用缓存作为访问值的主要入口了。</p>
<h4 id="33异步加载">3.3、异步加载</h4>
<p>此策略的工作原理与前一个相同，但是会异步执行操作并返回一个<code>CompletableFuture</code>来保存实际的值：</p>
<pre><code class="language-java">AsyncLoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()
  .maximumSize(100)
  .expireAfterWrite(1, TimeUnit.MINUTES)
  .buildAsync(k -&gt; DataObject.get(&quot;Data for &quot; + k));
</code></pre>
<p>我们可以以相同的方式使用<code>get</code>和<code>getAll</code>方法，考虑到它们的返回是<code>CompletableFuture</code>：</p>
<pre><code class="language-java">String key = &quot;A&quot;;

cache.get(key).thenAccept(dataObject -&gt; {
    assertNotNull(dataObject);
    assertEquals(&quot;Data for &quot; + key, dataObject.getData());
});

cache.getAll(Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;))
  .thenAccept(dataObjectMap -&gt; assertEquals(3, dataObjectMap.size()));
</code></pre>
<p>CompletableFuture具有很多有用的API，您可以在本文中阅读更多相关信息。</p>
<h3 id="4缓存值的清理">4、缓存值的清理</h3>
<p>Caffeine有三种缓存值的清理策略：基于大小、基于时间和基于引用。</p>
<h4 id="41基于大小的清理">4.1、基于大小的清理</h4>
<p>这种类型的清理设计为在超出缓存配置的大小限制时发生清理。有两种获取大小的方法——计算缓存中的对象数，或者获取它们的权重。</p>
<p>让我们看看如何计算缓存中的对象数。缓存初始化时，其大小为零：</p>
<pre><code class="language-java">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()
  .maximumSize(1)
  .build(k -&gt; DataObject.get(&quot;Data for &quot; + k));

assertEquals(0, cache.estimatedSize());
</code></pre>
<p>当我们添加一个值时，大小明显增加：</p>
<pre><code class="language-java">cache.get(&quot;A&quot;);

assertEquals(1, cache.estimatedSize());
</code></pre>
<p>我们可以将第二个值添加到缓存中，这会导致删除第一个值：</p>
<pre><code class="language-java">cache.get(&quot;B&quot;);
cache.cleanUp();

assertEquals(1, cache.estimatedSize());
</code></pre>
<p>值得一提的是，我们在获取缓存大小之前调用了<code>cleanUp</code>方法。这是因为缓存清理是异步执行的，该方法有助于等待清理完成。</p>
<p>我们还可以传入一个<code>weigher</code>的Function来定义缓存大小的获取：</p>
<pre><code class="language-java">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()
  .maximumWeight(10)
  .weigher((k,v) -&gt; 5)
  .build(k -&gt; DataObject.get(&quot;Data for &quot; + k));

assertEquals(0, cache.estimatedSize());

cache.get(&quot;A&quot;);
assertEquals(1, cache.estimatedSize());

cache.get(&quot;B&quot;);
assertEquals(2, cache.estimatedSize());
</code></pre>
<p>当权重超过 10 时，这些值将从缓存中删除：</p>
<pre><code class="language-java">cache.get(&quot;C&quot;);
cache.cleanUp();

assertEquals(2, cache.estimatedSize());
</code></pre>
<h4 id="42基于时间的清理">4.2、基于时间的清理</h4>
<p>这种清理策略基于条目的过期时间，分为三种：</p>
<ul>
<li>访问后过期——自上次读取或写入以来，条目在经过某段时间后过期</li>
<li>写入后过期——自上次写入以来，条目在经过某段时间后过期</li>
<li>自定义策略——由<code>Expiry</code>的实现来为每个条目单独计算到期时间</li>
</ul>
<p>让我们使用<code>expireAfterAccess</code>方法配置访问后过期策略：</p>
<pre><code class="language-java">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()
  .expireAfterAccess(5, TimeUnit.MINUTES)
  .build(k -&gt; DataObject.get(&quot;Data for &quot; + k));
</code></pre>
<p>要配置写入后过期策略，我们使用<code>expireAfterWrite</code>方法：</p>
<pre><code class="language-java">cache = Caffeine.newBuilder()
  .expireAfterWrite(10, TimeUnit.SECONDS)
  .weakKeys()
  .weakValues()
  .build(k -&gt; DataObject.get(&quot;Data for &quot; + k));
</code></pre>
<p>要初始化自定义策略，我们需要实现Expiry接口：</p>
<pre><code class="language-java">cache = Caffeine.newBuilder().expireAfter(new Expiry&lt;String, DataObject&gt;() {
    @Override
    public long expireAfterCreate(
      String key, DataObject value, long currentTime) {
        return value.getData().length() * 1000;
    }
    @Override
    public long expireAfterUpdate(
      String key, DataObject value, long currentTime, long currentDuration) {
        return currentDuration;
    }
    @Override
    public long expireAfterRead(
      String key, DataObject value, long currentTime, long currentDuration) {
        return currentDuration;
    }
}).build(k -&gt; DataObject.get(&quot;Data for &quot; + k));
</code></pre>
<h4 id="43基于引用的清理">4.3、基于引用的清理</h4>
<p>我们可以配置我们的缓存，允许缓存的键或值或二者一起的垃圾收集。为此，我们需要为键和值配置<code>WeakReference</code>的使用，并且我们可以配置<code>SoftReference</code>仅用于值的垃圾收集。</p>
<p><code>WeakReference</code>的使用允许在没有对对象的任何强引用时对对象进行垃圾回收。<code>SoftReference</code>允许基于JVM的全局LRU（最近最少使用）策略对对象进行垃圾回收。可以在此处找到有关Java中引用的更多详细信息。</p>
<p>我们使用Caffeine.weakKeys()、Caffeine.weakValues()和Caffeine.softValues()来启用每个选项：</p>
<pre><code class="language-java">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()
  .expireAfterWrite(10, TimeUnit.SECONDS)
  .weakKeys()
  .weakValues()
  .build(k -&gt; DataObject.get(&quot;Data for &quot; + k));

cache = Caffeine.newBuilder()
  .expireAfterWrite(10, TimeUnit.SECONDS)
  .softValues()
  .build(k -&gt; DataObject.get(&quot;Data for &quot; + k));
</code></pre>
<h3 id="5缓存刷新">5、缓存刷新</h3>
<p>可以将缓存配置为在定义的时间段后自动刷新条目。让我们看看如何使用refreshAfterWrite方法做到这一点：</p>
<pre><code class="language-java">Caffeine.newBuilder()
  .refreshAfterWrite(1, TimeUnit.MINUTES)
  .build(k -&gt; DataObject.get(&quot;Data for &quot; + k));
</code></pre>
<p>在这里，我们应该明白expireAfter和refreshAfter的一个区别：当请求过期条目时，执行会阻塞，直到build函数计算出新值。但是如果该条目符合刷新条件，则缓存将返回一个旧值并异步重新加载该值。</p>
<h3 id="6统计">6、统计</h3>
<p>Caffeine提供了一种记录缓存使用统计信息的方法：</p>
<pre><code class="language-java">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()
  .maximumSize(100)
  .recordStats()
  .build(k -&gt; DataObject.get(&quot;Data for &quot; + k));
cache.get(&quot;A&quot;);
cache.get(&quot;A&quot;);

assertEquals(1, cache.stats().hitCount());
assertEquals(1, cache.stats().missCount());
</code></pre>
<p>我们还可以创建一个<code>StatsCounter</code>的实现作为参数来传入<code>recordStats</code>。每次与统计相关的更改，这个实现对象都将被调用。</p>
<h3 id="7结论">7、结论</h3>
<p>在本文中，我们熟悉了Java的Caffeine缓存库。我们看到了如何配置和存入缓存，以及如何根据需要选择合适的过期或刷新策略。</p>
    </div>
</article>




            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">首页</a>
            </li>
            
            <li>
                <a href="/archives/">归档</a>
            </li>
            
            <li>
                <a href="/about/">关于</a>
            </li>
            
            <li>
                <a href="/search/">搜索</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/eyougo" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/caching/">Caching</a>
            </span>
            
            <span>
                <a href="/tags/java/">Java</a>
            </span>
            
            <span>
                <a href="/tags/redis/">Redis</a>
            </span>
            
            <span>
                <a href="/tags/spring-boot/">Spring Boot</a>
            </span>
            
            <span>
                <a href="/tags/spring-data/">Spring Data</a>
            </span>
            
            <span>
                <a href="/tags/testing/">Testing</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1简介">1、简介</a></li>
        <li><a href="#2依赖">2、依赖</a></li>
        <li><a href="#3写入缓存">3、写入缓存</a></li>
        <li><a href="#4缓存值的清理">4、缓存值的清理</a></li>
        <li><a href="#5缓存刷新">5、缓存刷新</a></li>
        <li><a href="#6统计">6、统计</a></li>
        <li><a href="#7结论">7、结论</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">首页</a>
            </li>
            
            <li>
                <a href="/archives/">归档</a>
            </li>
            
            <li>
                <a href="/about/">关于</a>
            </li>
            
            <li>
                <a href="/search/">搜索</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/eyougo" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/caching/">Caching</a>
            </span>
            
            <span>
                <a href="/tags/java/">Java</a>
            </span>
            
            <span>
                <a href="/tags/redis/">Redis</a>
            </span>
            
            <span>
                <a href="/tags/spring-boot/">Spring Boot</a>
            </span>
            
            <span>
                <a href="/tags/spring-data/">Spring Data</a>
            </span>
            
            <span>
                <a href="/tags/testing/">Testing</a>
            </span>
            
        </div>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1简介">1、简介</a></li>
        <li><a href="#2依赖">2、依赖</a></li>
        <li><a href="#3写入缓存">3、写入缓存</a></li>
        <li><a href="#4缓存值的清理">4、缓存值的清理</a></li>
        <li><a href="#5缓存刷新">5、缓存刷新</a></li>
        <li><a href="#6统计">6、统计</a></li>
        <li><a href="#7结论">7、结论</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2021-2021
                <a href="https://pinmost.com">码农熊猫</a>
                 | <a href="https://github.com/eyougo/hugo">Source code</a> 
                | 基于 <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 构建
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script defer src="/assets/js/fuji.min.js"></script>



</body>

</html>
