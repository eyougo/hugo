[{"content":"1、简介 在本文中，我们将了解Caffeine，一个用于Java的高性能缓存库。\n缓存和Map之间的一个根本区别是缓存会清理存储的项目。\n一个清理策略会决定在某个给定时间哪些对象应该被删除，这个策略直接影响缓存的命中率——缓存库的一个关键特性。\nCaffeine使用Window TinyLfu清理策略，它提供了接近最佳的命中率。\n2、依赖 我们需要将Caffeine依赖添加到我们的pom.xml中：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.ben-manes.caffeine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;caffeine\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  您可以在Maven Central上找到最新版本的Caffeine。\n3、写入缓存 让我们关注Caffeine的三种缓存写入策略：手动、同步加载和异步加载。\n首先，让我们编写一个类，作为要存储在缓存中的值的类型：\nclass DataObject { private final String data; private static int objectCounter = 0; // standard constructors/getters public static DataObject get(String data) { objectCounter++; return new DataObject(data); } }  3.1、手动写入 在此策略中，我们手动将值写入缓存并稍后读取它们。\n我们先初始化缓存：\nCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .expireAfterWrite(1, TimeUnit.MINUTES) .maximumSize(100) .build();  现在，我们可以使用getIfPresent方法从缓存中获取一些值。如果缓存中不存在该值，则此方法将返回null：\nString key = \u0026quot;A\u0026quot;; DataObject dataObject = cache.getIfPresent(key); assertNull(dataObject);  我们可以使用put方法手动写入缓存：\ncache.put(key, dataObject); dataObject = cache.getIfPresent(key); assertNotNull(dataObject);  我们还可以使用get方法获取值，该方法接受一个函数和一个键作为参数。如果缓存中不存在该键，则此函数将用于提供兜底值，该值将在执行后写入缓存：\ndataObject = cache .get(key, k -\u0026gt; DataObject.get(\u0026quot;Data for A\u0026quot;)); assertNotNull(dataObject); assertEquals(\u0026quot;Data for A\u0026quot;, dataObject.getData());  这个GET方法执行是原子性的。这意味着即使多个线程同时请求该值，执行只会进行一次。这就是为什么使用get比getIfPresent更好。\n有时我们需要手动使一些缓存的值失效：\ncache.invalidate(key); dataObject = cache.getIfPresent(key); assertNull(dataObject);  3.2、同步加载 这种加载缓存的方法需要一个Function，用于初始化写入值，类似于手动写入策略的get方法，让我们看看如何使用它。\n首先，我们需要初始化我们的缓存：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumSize(100) .expireAfterWrite(1, TimeUnit.MINUTES) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  现在我们可以使用get方法读取值：\nDataObject dataObject = cache.get(key); assertNotNull(dataObject); assertEquals(\u0026quot;Data for \u0026quot; + key, dataObject.getData());  我们还可以使用getAll方法获取一组值：\nMap\u0026lt;String, DataObject\u0026gt; dataObjectMap = cache.getAll(Arrays.asList(\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;)); assertEquals(3, dataObjectMap.size());  值从传递给build方法的底层后端初始化Function中读取到，这样就可以使用缓存作为访问值的主要入口了。\n3.3、异步加载 此策略的工作原理与前一个相同，但是会异步执行操作并返回一个CompletableFuture来保存实际的值：\nAsyncLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumSize(100) .expireAfterWrite(1, TimeUnit.MINUTES) .buildAsync(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  我们可以以相同的方式使用get和getAll方法，考虑到它们的返回是CompletableFuture：\nString key = \u0026quot;A\u0026quot;; cache.get(key).thenAccept(dataObject -\u0026gt; { assertNotNull(dataObject); assertEquals(\u0026quot;Data for \u0026quot; + key, dataObject.getData()); }); cache.getAll(Arrays.asList(\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;)) .thenAccept(dataObjectMap -\u0026gt; assertEquals(3, dataObjectMap.size()));  CompletableFuture具有很多有用的API，您可以在本文中阅读更多相关信息。\n4、缓存值的清理 Caffeine有三种缓存值的清理策略：基于大小、基于时间和基于引用。\n4.1、基于大小的清理 这种类型的清理设计为在超出缓存配置的大小限制时发生清理。有两种获取大小的方法——计算缓存中的对象数，或者获取它们的权重。\n让我们看看如何计算缓存中的对象数。缓存初始化时，其大小为零：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumSize(1) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k)); assertEquals(0, cache.estimatedSize());  当我们添加一个值时，大小明显增加：\ncache.get(\u0026quot;A\u0026quot;); assertEquals(1, cache.estimatedSize());  我们可以将第二个值添加到缓存中，这会导致删除第一个值：\ncache.get(\u0026quot;B\u0026quot;); cache.cleanUp(); assertEquals(1, cache.estimatedSize());  值得一提的是，我们在获取缓存大小之前调用了cleanUp方法。这是因为缓存清理是异步执行的，该方法有助于等待清理完成。\n我们还可以传入一个weigher的Function来定义缓存大小的获取：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumWeight(10) .weigher((k,v) -\u0026gt; 5) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k)); assertEquals(0, cache.estimatedSize()); cache.get(\u0026quot;A\u0026quot;); assertEquals(1, cache.estimatedSize()); cache.get(\u0026quot;B\u0026quot;); assertEquals(2, cache.estimatedSize());  当权重超过 10 时，这些值将从缓存中删除：\ncache.get(\u0026quot;C\u0026quot;); cache.cleanUp(); assertEquals(2, cache.estimatedSize());  4.2、基于时间的清理 这种清理策略基于条目的过期时间，分为三种：\n 访问后过期——自上次读取或写入以来，条目在经过某段时间后过期 写入后过期——自上次写入以来，条目在经过某段时间后过期 自定义策略——由Expiry的实现来为每个条目单独计算到期时间  让我们使用expireAfterAccess方法配置访问后过期策略：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .expireAfterAccess(5, TimeUnit.MINUTES) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  要配置写入后过期策略，我们使用expireAfterWrite方法：\ncache = Caffeine.newBuilder() .expireAfterWrite(10, TimeUnit.SECONDS) .weakKeys() .weakValues() .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  要初始化自定义策略，我们需要实现Expiry接口：\ncache = Caffeine.newBuilder().expireAfter(new Expiry\u0026lt;String, DataObject\u0026gt;() { @Override public long expireAfterCreate( String key, DataObject value, long currentTime) { return value.getData().length() * 1000; } @Override public long expireAfterUpdate( String key, DataObject value, long currentTime, long currentDuration) { return currentDuration; } @Override public long expireAfterRead( String key, DataObject value, long currentTime, long currentDuration) { return currentDuration; } }).build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  4.3、基于引用的清理 我们可以配置我们的缓存，允许缓存的键或值或二者一起的垃圾收集。为此，我们需要为键和值配置WeakReference的使用，并且我们可以配置SoftReference仅用于值的垃圾收集。\nWeakReference的使用允许在没有对对象的任何强引用时对对象进行垃圾回收。SoftReference允许基于JVM的全局LRU（最近最少使用）策略对对象进行垃圾回收。可以在此处找到有关Java中引用的更多详细信息。\n我们使用Caffeine.weakKeys()、Caffeine.weakValues()和Caffeine.softValues()来启用每个选项：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .expireAfterWrite(10, TimeUnit.SECONDS) .weakKeys() .weakValues() .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k)); cache = Caffeine.newBuilder() .expireAfterWrite(10, TimeUnit.SECONDS) .softValues() .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  5、缓存刷新 可以将缓存配置为在定义的时间段后自动刷新条目。让我们看看如何使用refreshAfterWrite方法做到这一点：\nCaffeine.newBuilder() .refreshAfterWrite(1, TimeUnit.MINUTES) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  在这里，我们应该明白expireAfter和refreshAfter的一个区别：当请求过期条目时，执行会阻塞，直到build函数计算出新值。但是如果该条目符合刷新条件，则缓存将返回一个旧值并异步重新加载该值。\n6、统计 Caffeine提供了一种记录缓存使用统计信息的方法：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumSize(100) .recordStats() .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k)); cache.get(\u0026quot;A\u0026quot;); cache.get(\u0026quot;A\u0026quot;); assertEquals(1, cache.stats().hitCount()); assertEquals(1, cache.stats().missCount());  我们还可以创建一个StatsCounter的实现作为参数来传入recordStats。每次与统计相关的更改，这个实现对象都将被调用。\n7、结论 在本文中，我们熟悉了Java的Caffeine缓存库。我们看到了如何配置和存入缓存，以及如何根据需要选择合适的过期或刷新策略。\n","date":"2021-07-06","permalink":"https://pinmost.com/post/java-caching-caffeine/","tags":["Java","Caching"],"title":"Caffeine缓存简单介绍"},{"content":"1、概述 Caffeine缓存是Java的高性能缓存库。在这个简短的教程中，我们将看到如何在Spring Boot中使用它。\n2、依赖 要开始使用Caffeine和Spring Boot，我们首先添加spring-boot-starter-cache和caffeine依赖项：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.ben-manes.caffeine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;caffeine\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  这些导入基本的Spring缓存支持以及Caffeine库。\n3、配置 现在我们需要在我们的Spring Boot应用程序中配置缓存。\n首先，我们创建一个caffeine的bean，用来控制缓存行为的主要配置，例如过期、缓存大小限制等：\n@Bean public Caffeine caffeineConfig() { return Caffeine.newBuilder().expireAfterWrite(60, TimeUnit.MINUTES); }  接下来，我们需要使用Spring CacheManager接口创建另一个bean。Caffeine提供了这个接口的实现，它需要我们上面创建的Caffeine对象：\n@Bean public CacheManager cacheManager(Caffeine caffeine) { CaffeineCacheManager caffeineCacheManager = new CaffeineCacheManager(); caffeineCacheManager.setCaffeine(caffeine); return caffeineCacheManager; }  最后，我们需要使用@EnableCaching注解在Spring Boot中启用缓存支持，这个注解可以添加到应用程序中的任何@Configuration类。\n4、例子 启用缓存并配置为使用Caffeine后，让我们看几个示例，说明如何在 Spring Boot 应用程序中使用缓存。\n在 Spring Boot 中使用缓存的主要方法是使用@Cacheable注解。此注解适用于 Spring bean（甚至整个类）的任何方法，它指示注册的缓存管理器将方法调用的结果存储在缓存中。\n一个典型的用法是在服务类中：\n@Service public class AddressService { @Cacheable public AddressDTO getAddress(long customerId) { // lookup and return result } }  使用不带参数的@Cacheable注解，Spring会为缓存和缓存的key使用默认名称。\n我们可以通过向注解添加一些参数来覆盖这两个做法：\n@Service public class AddressService { @Cacheable(value = \u0026quot;address_cache\u0026quot;, key = \u0026quot;customerId\u0026quot;) public AddressDTO getAddress(long customerId) { // lookup and return result } }  上面的示例告诉Spring使用名为address_cache的缓存和以customerId参数作为缓存key。\n最后，因为缓存管理器本身就是一个Spring bean，我们也可以将它自动装配到任何其他bean中并直接使用它：\n@Service public class AddressService { @Autowired CacheManager cacheManager; public AddressDTO getAddress(long customerId) { if(cacheManager.containsKey(customerId)) { return cacheManager.get(customerId); } // lookup address, cache result, and return it } }  5、结论 在本教程中，我们已经了解了如何配置Spring Boot以使用Caffeine缓存，以及如何在我们的应用程序中使用缓存的一些示例。\n","date":"2021-07-06","permalink":"https://pinmost.com/post/spring-boot-caffeine-cache/","tags":["Spring Boot","Caching"],"title":"在Spring Boot中使用Caffeine缓存"},{"content":"1、概述 Spring Data Redis提供了一种与Redis实例集成的简单方法。\n但是，在某些情况下，使用嵌入式服务器比使用真实服务器创建开发和测试环境更方便。\n因此，我们将学习如何设置和使用嵌入式Redis服务器。\n2、依赖 让我们首先添加必要的依赖项：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;it.ozimov\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;embedded-redis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.7.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  这个spring-boot-starter-test包含我们需要运行集成测试的各种依赖。\n此外，embedded-redis包含我们将使用的嵌入式服务器。\n3、设置 添加依赖项后，我们应该定义Redis服务器和我们的应用程序之间的连接设置。\n让我们首先创建一个类来保存我们的属性：\n@Configuration public class RedisProperties { private int redisPort; private String redisHost; public RedisProperties( @Value(\u0026quot;${spring.redis.port}\u0026quot;) int redisPort, @Value(\u0026quot;${spring.redis.host}\u0026quot;) String redisHost) { this.redisPort = redisPort; this.redisHost = redisHost; } // getters }  接下来，我们应该创建一个配置类来定义连接并使用我们的属性：\n@Configuration @EnableRedisRepositories public class RedisConfiguration { @Bean public LettuceConnectionFactory redisConnectionFactory( RedisProperties redisProperties) { return new LettuceConnectionFactory( redisProperties.getRedisHost(), redisProperties.getRedisPort()); } @Bean public RedisTemplate\u0026lt;?, ?\u0026gt; redisTemplate(LettuceConnectionFactory connectionFactory) { RedisTemplate\u0026lt;byte[], byte[]\u0026gt; template = new RedisTemplate\u0026lt;\u0026gt;(); template.setConnectionFactory(connectionFactory); return template; } }  配置非常简单。这样我们的嵌入式服务器可以在其他的端口上运行。\n4、嵌入式Redis服务器 现在，我们将配置嵌入式服务器并在我们的一项测试中使用它。\n首先，让我们在测试的资源目录（src/test/resources）中创建一个application.properties文件：\nspring.redis.host=localhost spring.redis.port=6370  之后，我们将创建一个@TestConfiguration注解的配置类：\n@TestConfiguration public class TestRedisConfiguration { private RedisServer redisServer; public TestRedisConfiguration(RedisProperties redisProperties) { this.redisServer = new RedisServer(redisProperties.getRedisPort()); } @PostConstruct public void postConstruct() { redisServer.start(); } @PreDestroy public void preDestroy() { redisServer.stop(); } }  当context上下文启动，服务器就跟着启动。它根据我们在属性中定义的端口运行在我们的机器上。有了它，我们现在可以在不停止实际Redis服务器的情况下运行测试了。\n理想情况下，我们希望在随机可用端口上启动它，但嵌入式Redis尚不具备此功能。我们现在可以做的是通过ServerSocket API 获取随机端口。\n此外，当上下文停止，服务器也跟着停止。\n服务器也可以由我们自己的可执行文件来提供：\nthis.redisServer = new RedisServer(\u0026quot;/path/redis\u0026quot;, redisProperties.getRedisPort());  此外，可执行文件可以按不同的操作系统来定义：\nRedisExecProvider customProvider = RedisExecProvider.defaultProvider() .override(OS.UNIX, \u0026quot;/path/unix/redis\u0026quot;) .override(OS.Windows, Architecture.x86_64, \u0026quot;/path/windows/redis\u0026quot;) .override(OS.MAC_OS_X, Architecture.x86_64, \u0026quot;/path/macosx/redis\u0026quot;); this.redisServer = new RedisServer(customProvider, redisProperties.getRedisPort());  最后，让我们创建一个使用TestRedisConfiguration类的测试吧：\n@RunWith(SpringRunner.class) @SpringBootTest(classes = TestRedisConfiguration.class) public class UserRepositoryIntegrationTest { @Autowired private UserRepository userRepository; @Test public void shouldSaveUser_toRedis() { UUID id = UUID.randomUUID(); User user = new User(id, \u0026quot;name\u0026quot;); User saved = userRepository.save(user); assertNotNull(saved); } }  这样用户保存就到了我们的嵌入式Redis服务器。\n此外，我们必须手动将TestRedisConfiguration添加到SpringBootTest。正如我们之前所说，服务器在测试之前启动并在测试之后停止。\n5、结论 嵌入式Redis服务器是在测试环境中替换实际服务器的完美工具。我们已经看到了如何配置它以及如何在我们的测试中使用它。\n","date":"2021-07-05","permalink":"https://pinmost.com/post/spring-embedded-redis/","tags":["Spring Boot","Testing","Redis"],"title":"嵌入式Redis服务器在Spring Boot测试中的使用"},{"content":"1、简介 在这个简短的教程中，我们将看看如何将Redis配置为Spring Boot缓存的数据存储。\n2、依赖 首先，让我们在pom.xml中添加spring-boot-starter-cache和spring-boot-starter-data-redis组件：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  这些添加了缓存支持并引入了所有必需的依赖项。\n3、配置 通过添加上述依赖项和@EnableCaching注解，Spring Boot 将使用默认缓存配置自动配置一个RedisCacheManager。但是，我们可以在缓存管理器初始化之前以几种有用的方式修改此配置。\n首先，让我们创建一个RedisCacheConfiguration bean：\n@Bean public RedisCacheConfiguration cacheConfiguration() { return RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(60)) .disableCachingNullValues() .serializeValuesWith(SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())); }  这使我们可以更好地控制默认配置——例如，我们可以设置所需的生存时间 (TTL) 值并自定义用于动态缓存创建的默认序列化策略。\n接下来，为了完全控制缓存设置，让我们注册我们自己的RedisCacheManagerBuilderCustomizer bean：\n@Bean public RedisCacheManagerBuilderCustomizer redisCacheManagerBuilderCustomizer() { return (builder) -\u0026gt; builder .withCacheConfiguration(\u0026quot;itemCache\u0026quot;, RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofMinutes(10))) .withCacheConfiguration(\u0026quot;customerCache\u0026quot;, RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofMinutes(5))); }  在这里，我们使用RedisCacheManagerBuilder和RedisCacheConfiguration分别为itemCache和customerCache配置了10分钟和5分钟的TTL值。这有助于在每个缓存的基础上进一步微调缓存行为，包括空值、键前缀和二进制序列化。\n值得一提的是，Redis实例的默认连接详细信息是localhost:6379。Redis配置可用于进一步调整更底层的连接细节以及主机和端口。\n4、例子 在我们的示例中，我们有一个ItemService组件，用于从数据库中检索项目信息。实际上，假设这是一个潜在的代价高昂的操作，是一个很好的使用缓存场景。\n首先，让我们使用嵌入式Redis服务器为该组件创建集成测试：\n@Import({ CacheConfig.class, ItemService.class}) @ExtendWith(SpringExtension.class) @EnableCaching @ImportAutoConfiguration(classes = { CacheAutoConfiguration.class, RedisAutoConfiguration.class }) class ItemServiceCachingIntegrationTest { @MockBean private ItemRepository mockItemRepository; @Autowired private ItemService itemService; @Autowired private CacheManager cacheManager; @Test void givenRedisCaching_whenFindItemById_thenItemReturnedFromCache() { Item anItem = new Item(AN_ID, A_DESCRIPTION); given(mockItemRepository.findById(AN_ID)) .willReturn(Optional.of(anItem)); Item itemCacheMiss = itemService.getItemForId(AN_ID); Item itemCacheHit = itemService.getItemForId(AN_ID); assertThat(itemCacheMiss).isEqualTo(anItem); assertThat(itemCacheHit).isEqualTo(anItem); verify(mockItemRepository, times(1)).findById(AN_ID); assertThat(itemFromCache()).isEqualTo(anItem); } }  在这里，我们为缓存行为创建一个测试切面并调用getItemForId两次。第一次调用应该从存储库中获取结果，但第二次调用应该从缓存中返回结果而不调用存储库。\n最后，让我们使用Spring的@Cacheable注解启用缓存行为：\n@Cacheable(value = \u0026quot;itemCache\u0026quot;) public Item getItemForId(String id) { return itemRepository.findById(id) .orElseThrow(RuntimeException::new); }  这就应用了缓存逻辑，同时依赖于我们之前配置的Redis缓存的基础架构。有关控制Spring缓存对象的属性和行为（包括数据更新和清除）的更多详细信息，可以参见Spring缓存指南文章。\n5、结论 在本文章中，我们已经看到了如何使用Redis进行Spring Boot缓存。\n","date":"2021-07-05","permalink":"https://pinmost.com/post/spring-boot-redis-cache/","tags":["Spring Data","Caching","Redis"],"title":"如何使用Redis作为Spring Boot缓存"}]