[{"content":"1、概述 Spring Retry 是Spring框架中的一个组件， 它提供了自动重新调用失败操作的能力。这在错误可能是暂时发生的（如瞬时网络故障）的情况下很有帮助。\n在本文中，我们将看到使用Spring Retry的各种方式：注解、RetryTemplate以及回调。\n2、Maven依赖 让我们首先将spring-retry依赖项添加到我们的pom.xml文件中：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.retry\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-retry\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.5.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  我们还需要将Spring AOP添加到我们的项目中：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aspects\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  可以查看Maven Central来获取最新版本的spring-retry 和spring-aspects 依赖项。\n3、开启Spring Retry 要在应用程序中启用Spring Retry，我们需要将@EnableRetry注释添加到我们的@Configuration类：\n@Configuration @EnableRetry public class AppConfig { ... }  4、使用Spring Retry 4.1、@Retryable而不用恢复 我们可以使用@Retryable注解为方法添加重试功能：\n@Service public interface MyService { @Retryable(value = RuntimeException.class) void retryService(String sql); }  在这里，当抛出RuntimeException时尝试重试。\n根据@Retryable的默认行为，重试最多可能发生3次，重试之间有1秒的延迟。\n4.2、@Retryable和@Recover 现在让我们使用@Recover注解添加一个恢复方法：\n@Service public interface MyService { @Retryable(value = SQLException.class) void retryServiceWithRecovery(String sql) throws SQLException; @Recover void recover(SQLException e, String sql); }  这里，当抛出SQLException时重试会尝试运行。 当@Retryable方法因指定异常而失败时，@Recover注解定义了一个单独的恢复方法。\n因此，如果retryServiceWithRecovery方法在三次尝试之后还是抛出了SQLException，那么recover()方法将被调用。\n恢复处理程序的第一个参数应该是Throwable类型（可选）和相同的返回类型。其余的参数按相同顺序从失败方法的参数列表中填充。\n4.3、自定义@Retryable的行为 为了自定义重试的行为，我们可以使用参数maxAttempts和backoff：\n@Service public interface MyService { @Retryable( value = SQLException.class, maxAttempts = 2, backoff = @Backoff(delay = 100)) void retryServiceWithCustomization(String sql) throws SQLException; }  这样最多将有两次尝试和100毫秒的延迟。\n4.4、使用Spring Properties 我们还可以在@Retryable注解中使用properties。\n为了演示这一点，我们将看到如何将delay和maxAttempts的值外部化到一个properties文件中。\n首先，让我们在名为retryConfig.properties的文件中定义属性：\nretry.maxAttempts=2 retry.maxDelay=100  然后我们指示@Configuration类加载这个文件：\n@PropertySource(\u0026quot;classpath:retryConfig.properties\u0026quot;) public class AppConfig { ... } // ...  最后，我们可以在@Retryable的定义中注入retry.maxAttempts和retry.maxDelay的值：\n@Service public interface MyService { @Retryable( value = SQLException.class, maxAttemptsExpression = \u0026quot;${retry.maxAttempts}\u0026quot;, backoff = @Backoff(delayExpression = \u0026quot;${retry.maxDelay}\u0026quot;)) void retryServiceWithExternalizedConfiguration(String sql) throws SQLException; }  请注意，我们现在使用的是maxAttemptsExpression和delayExpression而不是maxAttempts和delay。\n5、RetryTemplate 5.1、RetryOperations Spring Retry提供了RetryOperations接口，它提供了一组execute()方法：\npublic interface RetryOperations { \u0026lt;T\u0026gt; T execute(RetryCallback\u0026lt;T\u0026gt; retryCallback) throws Exception; ... }  execute()方法的参数RetryCallback，是一个接口，可以插入需要在失败时重试的业务逻辑：\npublic interface RetryCallback\u0026lt;T\u0026gt; { T doWithRetry(RetryContext context) throws Throwable; }  5.2、RetryTemplate配置 RetryTemplate是RetryOperations的一个实现。\n让我们在@Configuration类中配置一个RetryTemplate的bean：\n@Configuration public class AppConfig { //... @Bean public RetryTemplate retryTemplate() { RetryTemplate retryTemplate = new RetryTemplate(); FixedBackOffPolicy fixedBackOffPolicy = new FixedBackOffPolicy(); fixedBackOffPolicy.setBackOffPeriod(2000l); retryTemplate.setBackOffPolicy(fixedBackOffPolicy); SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy(); retryPolicy.setMaxAttempts(2); retryTemplate.setRetryPolicy(retryPolicy); return retryTemplate; } }  这个RetryPolicy确定了何时应该重试操作。\n其中SimpleRetryPolicy定义了重试的固定次数，另一方面，BackOffPolicy用于控制重试尝试之间的回退。\n最后，FixedBackOffPolicy会使重试在继续之前暂停一段固定的时间。\n5.3、使用RetryTemplate 要使用重试处理来运行代码，我们可以调用retryTemplate.execute()方法：\nretryTemplate.execute(new RetryCallback\u0026lt;Void, RuntimeException\u0026gt;() { @Override public Void doWithRetry(RetryContext arg0) { myService.templateRetryService(); ... } });  我们可以使用lambda表达式代替匿名类：\nretryTemplate.execute(arg0 -\u0026gt; { myService.templateRetryService(); return null; });  6、监听器 监听器在重试时提供另外的回调。我们可以用这些来关注跨不同重试的各个横切点。\n6.1、添加回调 回调在RetryListener接口中提供：\npublic class DefaultListenerSupport extends RetryListenerSupport { @Override public \u0026lt;T, E extends Throwable\u0026gt; void close(RetryContext context, RetryCallback\u0026lt;T, E\u0026gt; callback, Throwable throwable) { logger.info(\u0026quot;onClose\u0026quot;); ... super.close(context, callback, throwable); } @Override public \u0026lt;T, E extends Throwable\u0026gt; void onError(RetryContext context, RetryCallback\u0026lt;T, E\u0026gt; callback, Throwable throwable) { logger.info(\u0026quot;onError\u0026quot;); ... super.onError(context, callback, throwable); } @Override public \u0026lt;T, E extends Throwable\u0026gt; boolean open(RetryContext context, RetryCallback\u0026lt;T, E\u0026gt; callback) { logger.info(\u0026quot;onOpen\u0026quot;); ... return super.open(context, callback); } }  open和close的回调在整个重试之前和之后执行，而onError应用于单个RetryCallback调用。\n6.2、注册监听器 接下来，我们将我们的监听器（DefaultListenerSupport）注册到我们的RetryTemplate bean：\n@Configuration public class AppConfig { ... @Bean public RetryTemplate retryTemplate() { RetryTemplate retryTemplate = new RetryTemplate(); ... retryTemplate.registerListener(new DefaultListenerSupport()); return retryTemplate; } }  7、测试结果 为了完成我们的示例，让我们验证一下结果：\n@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration( classes = AppConfig.class, loader = AnnotationConfigContextLoader.class) public class SpringRetryIntegrationTest { @Autowired private MyService myService; @Autowired private RetryTemplate retryTemplate; @Test(expected = RuntimeException.class) public void givenTemplateRetryService_whenCallWithException_thenRetry() { retryTemplate.execute(arg0 -\u0026gt; { myService.templateRetryService(); return null; }); } }  从测试日志中可以看出，我们已经正确配置了RetryTemplate和RetryListener：\n2020-01-09 20:04:10 [main] INFO c.p.s.DefaultListenerSupport - onOpen 2020-01-09 20:04:10 [main] INFO c.pinmost.springretry.MyServiceImpl - throw RuntimeException in method templateRetryService() 2020-01-09 20:04:10 [main] INFO c.p.s.DefaultListenerSupport - onError 2020-01-09 20:04:12 [main] INFO c.pinmost.springretry.MyServiceImpl - throw RuntimeException in method templateRetryService() 2020-01-09 20:04:12 [main] INFO c.p.s.DefaultListenerSupport - onError 2020-01-09 20:04:12 [main] INFO c.p.s.DefaultListenerSupport - onClose  8、结论 在本文中，我们看到了如何使用注解、RetryTemplate和回调监听器来使用Spring Retry。\n","date":"2021-07-22","permalink":"https://pinmost.com/post/spring-retry/","tags":["Spring","Spring Retry"],"title":"Spring框架中一个有用的小组件：Spring Retry"},{"content":" 原文地址：https://juejin.cn/post/6981315563104501790\n原作者：这些年你跑哪去了\n 从Performance、Performance API、LightHouse三个方向来分析前端性能。\n1 Performance  运行时性能表现（runtime performance）指的是当你的页面在浏览器运行时的性能表现，而不是在下载页面的时候的表现。用 Chrome DevToos Performance 功能去分析运行时性能表现。\n 1.1 面板初始化简介 1.2 demo 简介 1.3 FPS图表 - Frames Per Seconds  分析每一秒的帧，FPS（frames per second）是用来分析动画的一个主要性能指标。让页面效果能够达到\u0026gt;=60fps(帧)/s的刷新频率以避免出现卡顿。\n  为什么是60fps? 目前大多数显示器的刷新率相吻合(60Hz)。如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。60 HZ/s，每个帧的工作（从 JS 到绘制）完成时间小于 16ms,达到人眼顺滑（例如滚动 拖动）。\n  观察FPS图表，如果你发现了一个红色的长条，那么就说明这些帧存在严重问题（有掉帧情况），有可能导致非常差的用户体验。一般来说，绿色的长条越高，说明FPS越高，用户体验越好。\n 1.4 Frames  more -\u0026gt; more tools -\u0026gt; Rendering -\u0026gt;Frame Rending Status 可看实时帧率。\n  more -\u0026gt; more tools -\u0026gt; Rendering -\u0026gt;Paint flashing 页面上有哪些内容被重绘了。\n  点击三角箭头展开 Frames 区域，鼠标悬浮/点击绿色方块，可以看到该特定帧的帧率和渲染耗时。\n 1.5 CPU 顏色块的表示：\n 蓝色为HTML文件 黃色为脚本 紫色为样式 绿色为媒体文件 灰色为其他資源   总结：当 CPU 长时间被占满，就是当前网页性能需要优化的信号。CPU 图表中，可以根据颜色填充的饱满程度，确定 CPU 的忙闲，进而了解该页面的总的任务量(鼠标悬停可见)。而 Summary 饼图则以一种直观的方式告诉了我们，哪个类型的任务最耗时。\n 1.6 HEAP  在 HEAP 图表中可以看到 JS 内存占用情况，与下方的 memory 窗格中的JS Heap相对应。在 Memory 窗格还可以看到 Document 文档、Nodes DOM 节点、监听器、GPU 内存的习份内存统计。\n 1.7 Network  鼠标悬停可以看到具体的网络请求以及获取请求的时间。网络请求时间过长会影响白屏时间。\n 1.8 事件时间点  FP：First Paint(页面在导航后首次呈现出不同于导航前内容的时间点)； FCP：First Contentful Paint(首次绘制任何文本，图像，非空白canvas或SVG的时间点)； LCP：Largest Contenful Paint(页面开始加载到最大文本块内容或图片显示在页面中的时间)； DCL：DOMContentLoaded Event(HTML加载完成事件) L：OnLoad Event(页面所有资源加载完成事件)。  1.9 Main  展开 Main 图表，Devtools 展示了主线程运行状况。X轴代表着时间。每个长条代表着一个 event。长条越长就代表这个 event花费的时间越长。Y轴代表了调用栈（call stack）。在栈里，上面的 event 调用了下面的event。 在事件长条的右上角出，如果出现了红色小三角，说明这个事件是存在问题的，需要特别注意。 双击这个带有红色小三角的的事件。在Summary 面板会看到详细信息。注意 reveal这个链接，双击它会让高亮触发这个事件的 event。如果点击代码提示链接，就会跳转到对应的代码处。  2 Performance API  在 performance 的 timing 属性中，我们可以查看到时间戳。在 performance 的 memory属性中可以查看浏览器内存情況。\n 2.1 这些时间戳与页面整个加载流程中的关键时间节点有着一一对应的关系 2.2 通过求两个时间点之间的差值，我们可以得出某个过程花费的时间 2.3 关键性能指标：firstbyte、fpt、tti、ready 和 load 时间 3 LightHouse  Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。为Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。\n 3.1 指标  页面性能、可访问性（无障碍）、最佳实践、SEO、PWA（渐进式 Web 应用） 五项指标的跑分。向下拉动 Report 页，我们还可以看到每一个指标的细化评。\n  在 “Opportunities” 中，LightHouse 甚至针对我们的性能问题给出了可行的建议、以及每一项优化操作预期会帮我们节省的时间。\n","date":"2021-07-20","permalink":"https://pinmost.com/post/web-performence/","tags":["Web","Performance"],"title":"三种方式分析监测web前端性能"},{"content":"1、简介 Apache HttpClient是一个底层、轻量级的客户端HTTP库，用于与HTTP服务器进行通信。 在本教程中，我们将学习如何在使用HttpClient时配置支持的传输层安全（TLS）版本。 我们将首先概述TLS版本协商如何在客户端和服务器之间工作。 之后，我们将看看在使用HttpClient时配置支持的TLS版本的三种不同方式。\n2、TLS版本协商 TLS是一种互联网协议，可在两方之间提供安全、可信的通信。它封装了像HTTP这样的应用层协议。 TLS协议自1999年首次发布以来已多次修订。 因此，客户端和服务器在建立新连接时，首先就他们将使用的TLS版本达成一致非常重要。 TLS版本在客户端和服务器交换hello消息后达成一致：\n 客户端发送支持的 TLS 版本列表。 服务器选择一个并在响应中包含所选版本。 客户端和服务器使用所选版本继续连接设置。  由于存在降级攻击的风险，因此正确配置Web客户端支持的TLS版本非常重要。 请注意，为了使用最新版本的TLS（TLS 1.3），我们必须使用Java 11或更高版本。\n3、固定设置TLS版本 3.1、SSLConnectionSocketFactory 让我们通过HttpClients#custom定制构建方法提供的HttpClientBuilder，来定制我们的HTTPClient配置。 此构建器模式允许我们传入我们自己的SSLConnectionSocketFactory，它将根据一组所需支持的TLS版本进行实例化：\nSSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory( SSLContexts.createDefault(), new String[] { \u0026quot;TLSv1.2\u0026quot;, \u0026quot;TLSv1.3\u0026quot; }, null, SSLConnectionSocketFactory.getDefaultHostnameVerifier()); CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(sslsf).build();  返回的Httpclient对象现在可以执行HTTP请求了。 通过在SSLConnectionSocketFactory构造函数中显式设置支持的协议，客户端将仅支持通过TLS 1.2或TLS 1.3的通信。 请注意，在 Apache HttpClient 4.3 之前的版本中，该类称为SSLSocketFactory。\n3.2、Java运行时参数 另外，我们可以使用Java的https.protocols系统属性配置支持的TLS版本。 此方法可以防止必须将值硬编码到应用程序代码中。 相反，我们将配置HttpClient以在设置连接时使用该系统属性。 HttpClient API提供了两种方法来实现。第一个是通过HttpClients#createSystem：\nCloseableHttpClient httpClient = HttpClients.createSystem();  如果需要更多的客户端配置，我们可以使用builder方法代替：\nCloseableHttpClient httpClient = HttpClients.custom().useSystemProperties().build();  这两种方法都告诉HttpClient在连接配置期间使用系统属性。 这允许我们在应用程序运行时使用命令行参数设置所需的TLS版本。例如：\n$ java -Dhttps.protocols=TLSv1.1,TLSv1.2,TLSv1.3 -jar webClient.jar  4、动态设置TLS版本 还可以根据主机名和端口等连接详细信息设置TLS版本。我们将扩展SSLConnectionSocketFactory并覆盖prepareSocket方法。 客户端会在启动新连接之前调用prepareSocket方法，这将可以让我们在每个连接的基础上决定使用哪些TLS协议。 也可以启用对旧TLS版本的支持，但前提是远程主机具有特定的子域：\nSSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(SSLContexts.createDefault()){ @Override protected void prepareSocket(SSLSocket socket) { String hostname = socket.getInetAddress().getHostName(); if (hostname.endsWith(\u0026quot;internal.system.com\u0026quot;)){ socket.setEnabledProtocols(new String[] { \u0026quot;TLSv1\u0026quot;, \u0026quot;TLSv1.1\u0026quot;, \u0026quot;TLSv1.2\u0026quot;, \u0026quot;TLSv1.3\u0026quot; }); } else { socket.setEnabledProtocols(new String[] {\u0026quot;TLSv1.3\u0026quot;}); } } }; CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(sslsf).build();  在上面的示例中，prepareSocket方法首先获取SSLSocket将连接到的远程主机名，然后使用主机名来确定要启用的TLS协议。 现在，我们的HTTP客户端将对每个请求强制执行TLS 1.3，除了目标主机名的格式为*.internal.system.com。 由于能够在创建新SSLSocket之前插入自定义逻辑，我们的应用程序现在可以自定义TLS通信的详细信息。\n5、结论 在本文中，我们研究了在使用Apache HttpClient库时配置支持的TLS版本的三种不同方式。 我们已经了解了如何为所有连接或基于每个连接设置TLS版本。\n 原文：https://www.baeldung.com/apache-httpclient-tls\n翻译：码农熊猫\n","date":"2021-07-20","permalink":"https://pinmost.com/post/apache-httpclient-tls/","tags":["HTTP Client-Side","Security"],"title":"如何在Apache HttpClient中设置TLS版本"},{"content":"1、缓存抽象？ 在本教程中，我们将学习如何在Spring中使用缓存抽象，并从总体上改进我们系统的性能。\n我们将为一些现实的方法示例启用简单的缓存，还将讨论如何通过智能的缓存管理来实际改进这些调用的性能。\n2、入门 Spring提供的核心缓存抽象位于 spring-context 模块中。 所以在使用Maven时，我们的pom.xml应该包含如下依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  有趣的是，还有另一个名为spring-context-support 的模块， 它位于spring-context模块的顶层，并提供了一些CacheManagers，由类似EhCache或Caffeine等提供支持。如果我们想将它们用作我们的缓存存储，那么我们需要改用spring-context-support模块：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  由于spring-context-support模块传递依赖于spring-context模块，因此不需要为spring-context单独声明依赖项。\n2.1、Spring Boot 如果我们使用Spring Boot，那么我们可以利用spring-boot-starter-cache 启动包来轻松添加缓存依赖项：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在这个封装下，启动包会引入spring-context-support模块。\n3、启用缓存 为了启用缓存，Spring充分利用了注解，就像启用框架中的任何其他配置级别功能一样。\n我们可以简单地通过在任何配置类中添加@EnableCaching注解来启用缓存功能：\n@Configuration @EnableCaching public class CachingConfig { @Bean public CacheManager cacheManager() { return new ConcurrentMapCacheManager(\u0026quot;addresses\u0026quot;); } }  当然，我们也可以使用XML配置启用缓存管理：\n\u0026lt;beans\u0026gt; \u0026lt;cache:annotation-driven /\u0026gt; \u0026lt;bean id=\u0026quot;cacheManager\u0026quot; class=\u0026quot;org.springframework.cache.support.SimpleCacheManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;caches\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean\u0026quot; name=\u0026quot;addresses\u0026quot;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  注意：启用缓存后，对于最基本的设置，我们必须注册一个cacheManager。\n3.1、使用Spring Boot 使用Spring Boot时，依赖的starter包与EnableCaching注释一起存在将注册相同的ConcurrentMapCacheManager，所以不需要单独的bean声明。\n此外，我们可以使用一个或多个CacheManagerCustomizer\u0026lt;T\u0026gt;bean来定制自动配置的CacheManager：\n@Component public class SimpleCacheCustomizer implements CacheManagerCustomizer\u0026lt;ConcurrentMapCacheManager\u0026gt; { @Override public void customize(ConcurrentMapCacheManager cacheManager) { cacheManager.setCacheNames(asList(\u0026quot;users\u0026quot;, \u0026quot;transactions\u0026quot;)); } }  这个CacheAutoConfiguration自动配置会找到这些定制类，并把它们应用到当前的CacheManager，在其完整初始化之前。\n4、使用注解缓存 启用缓存后，下一步是将缓存行为绑定到声明了注解的方法。\n4.1、@Cacheable 为方法启用缓存行为的最简单方法是使用@Cacheable对其进行标注，并使用要存储结果的缓存名称作为其参数：\n@Cacheable(\u0026quot;addresses\u0026quot;) public String getAddress(Customer customer) {...}  这个getAddress()被调用时，将在实际调用方法之前首先检查缓存addresses，之后缓存方法的结果。\n虽然在大多数情况下一个缓存就足够了，但Spring框架也支持多个缓存作为参数传递：\n@Cacheable({\u0026quot;addresses\u0026quot;, \u0026quot;directory\u0026quot;}) public String getAddress(Customer customer) {...}  在这种情况下，如果任何缓存包含所需的结果，则返回结果并且不调用实际方法。\n4.2、@CacheEvict 现在，如果让所有方法都@Cacheable会有什么问题？\n问题是缓存大小。不是经常需要读取的值，我们并不需要存入缓存。缓存会增长得非常大，非常快，我们可能会保留大量陈旧或不使用的数据。\n我们可以使用@CacheEvict注解来指示删除一个或多个/所有的值，以便可以再次将新值加载到缓存中：\n@CacheEvict(value=\u0026quot;addresses\u0026quot;, allEntries=true) public String getAddress(Customer customer) {...}  在这里，我们添加了额外参数allEntries与要清空的缓存一起使用，这将清除addresses缓存中的所有条目并为新数据做好准备。\n4.3、@CachePut 虽然@CacheEvict通过删除陈旧和未使用的条目来减少在大型缓存中查找条目的开销，但我们希望避免从缓存中清理太多数据。\n相反，每当我们更改条目时，我们都可以选择更新条目。\n使用@CachePut注解，我们可以在不干扰方法执行的情况下更新缓存的内容。也就是说，该方法将始终执行并缓存结果：\n@CachePut(value=\u0026quot;addresses\u0026quot;) public String getAddress(Customer customer) {...}  @Cacheable和@CachePut之间的区别是@Cacheable将跳过运行的方法，而@CachePut将实际运行方法，然后把它的结果存在缓存中。\n4.4、@Cache 如果我们想使用多个相同类型的注解来标注一个方法的缓存怎么办？让我们看一个不正确的例子：\n@CacheEvict(\u0026quot;addresses\u0026quot;) @CacheEvict(value=\u0026quot;directory\u0026quot;, key=customer.name) public String getAddress(Customer customer) {...}  上面的代码将无法编译，因为Java不允许为给定的方法声明多个相同类型的注解。\n上述问题的解决方法是：\n@Caching(evict = { @CacheEvict(\u0026quot;addresses\u0026quot;), @CacheEvict(value=\u0026quot;directory\u0026quot;, key=\u0026quot;#customer.name\u0026quot;) }) public String getAddress(Customer customer) {...}  如上面的代码片段所示，我们可以使用@Caching将多个缓存注解分组，并使用它来实现我们自己自定义的缓存逻辑。\n4.5、@CacheConfig 使用@CacheConfig注解，我们可以在类级别将一些缓存配置简化到一个地方，这样我们就不必多次声明：\n@CacheConfig(cacheNames={\u0026quot;addresses\u0026quot;}) public class CustomerDataService { @Cacheable public String getAddress(Customer customer) {...}  5、有条件的缓存 有时，缓存可能无法对一个方法在所有情况下都适用。\n重用我们在@CachePut注解中的示例，这将每次都执行该方法并缓存结果：\n@CachePut(value=\u0026quot;addresses\u0026quot;) public String getAddress(Customer customer) {...}  5.1、Condition参数 如果我们想要更多地控制注解何时被激活，我们可以使用一个condition参数作为参数传递给@CachePut，该参数接收了一个SpEL表达式并基于该表达式的计算来对结果进行缓存：\n@CachePut(value=\u0026quot;addresses\u0026quot;, condition=\u0026quot;#customer.name=='Tom'\u0026quot;) public String getAddress(Customer customer) {...}  5.2. Unless参数 我们还可以通过unless参数根据方法的输出而不是输入来控制缓存：\n@CachePut(value=\u0026quot;addresses\u0026quot;, unless=\u0026quot;#result.length()\u0026lt;64\u0026quot;) public String getAddress(Customer customer) {...}  上述注解将缓存addresses，除非它们短于64个字符。\n重要的是要知道Condition和unless参数可以与所有缓存注解结合使用。\n事实证明，这种条件缓存对于管理大型结果非常有效。它也可用于根据输入参数自定义行为，而不是对所有操作强制执行通用行为。\n6、基于XML的声明式缓存 如果我们无法访问应用程序的源代码，或者想要在外部注入缓存行为，我们还可以使用基于XML的声明性缓存。\n这是我们的 XML 配置：\n\u0026lt;!-- the service that you wish to make cacheable --\u0026gt; \u0026lt;bean id=\u0026quot;customerDataService\u0026quot; class=\u0026quot;com.your.app.namespace.service.CustomerDataService\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;cacheManager\u0026quot; class=\u0026quot;org.springframework.cache.support.SimpleCacheManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;caches\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean\u0026quot; name=\u0026quot;directory\u0026quot;/\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean\u0026quot; name=\u0026quot;addresses\u0026quot;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- define caching behavior --\u0026gt; \u0026lt;cache:advice id=\u0026quot;cachingBehavior\u0026quot; cache-manager=\u0026quot;cacheManager\u0026quot;\u0026gt; \u0026lt;cache:caching cache=\u0026quot;addresses\u0026quot;\u0026gt; \u0026lt;cache:cacheable method=\u0026quot;getAddress\u0026quot; key=\u0026quot;#customer.name\u0026quot;/\u0026gt; \u0026lt;/cache:caching\u0026gt; \u0026lt;/cache:advice\u0026gt; \u0026lt;!-- apply the behavior to all the implementations of CustomerDataService interface-\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;cachingBehavior\u0026quot; pointcut=\u0026quot;execution(* com.your.app.namespace.service.CustomerDataService.*(..))\u0026quot;/\u0026gt; \u0026lt;/aop:config\u0026gt;  7、基于Java的缓存 这是等效的Java配置：\n@Configuration @EnableCaching public class CachingConfig { @Bean public CacheManager cacheManager() { SimpleCacheManager cacheManager = new SimpleCacheManager(); cacheManager.setCaches(Arrays.asList( new ConcurrentMapCache(\u0026quot;directory\u0026quot;), new ConcurrentMapCache(\u0026quot;addresses\u0026quot;))); return cacheManager; } }  这是我们的CustomerDataService：\n@Component public class CustomerDataService { @Cacheable(value = \u0026quot;addresses\u0026quot;, key = \u0026quot;#customer.name\u0026quot;) public String getAddress(Customer customer) { return customer.getAddress(); } }  8、总结 在本文中，我们讨论了Spring中缓存的基础知识，以及如何通过注解恰当地使用这个抽象。\n","date":"2021-07-07","permalink":"https://pinmost.com/post/spring-cache-tutorial/","tags":["Spring","Caching"],"title":"Spring缓存指南"},{"content":"1、简介 在本文中，我们将了解Caffeine，一个用于Java的高性能缓存库。\n缓存和Map之间的一个根本区别是缓存会清理存储的项目。\n一个清理策略会决定在某个给定时间哪些对象应该被删除，这个策略直接影响缓存的命中率——缓存库的一个关键特性。\nCaffeine使用Window TinyLfu清理策略，它提供了接近最佳的命中率。\n2、依赖 我们需要将Caffeine依赖添加到我们的pom.xml中：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.ben-manes.caffeine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;caffeine\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  您可以在Maven Central上找到最新版本的Caffeine。\n3、写入缓存 让我们关注Caffeine的三种缓存写入策略：手动、同步加载和异步加载。\n首先，让我们编写一个类，作为要存储在缓存中的值的类型：\nclass DataObject { private final String data; private static int objectCounter = 0; // standard constructors/getters public static DataObject get(String data) { objectCounter++; return new DataObject(data); } }  3.1、手动写入 在此策略中，我们手动将值写入缓存并稍后读取它们。\n我们先初始化缓存：\nCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .expireAfterWrite(1, TimeUnit.MINUTES) .maximumSize(100) .build();  现在，我们可以使用getIfPresent方法从缓存中获取一些值。如果缓存中不存在该值，则此方法将返回null：\nString key = \u0026quot;A\u0026quot;; DataObject dataObject = cache.getIfPresent(key); assertNull(dataObject);  我们可以使用put方法手动写入缓存：\ncache.put(key, dataObject); dataObject = cache.getIfPresent(key); assertNotNull(dataObject);  我们还可以使用get方法获取值，该方法接受一个函数和一个键作为参数。如果缓存中不存在该键，则此函数将用于提供兜底值，该值将在执行后写入缓存：\ndataObject = cache .get(key, k -\u0026gt; DataObject.get(\u0026quot;Data for A\u0026quot;)); assertNotNull(dataObject); assertEquals(\u0026quot;Data for A\u0026quot;, dataObject.getData());  这个GET方法执行是原子性的。这意味着即使多个线程同时请求该值，执行只会进行一次。这就是为什么使用get比getIfPresent更好。\n有时我们需要手动使一些缓存的值失效：\ncache.invalidate(key); dataObject = cache.getIfPresent(key); assertNull(dataObject);  3.2、同步加载 这种加载缓存的方法需要一个Function，用于初始化写入值，类似于手动写入策略的get方法，让我们看看如何使用它。\n首先，我们需要初始化我们的缓存：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumSize(100) .expireAfterWrite(1, TimeUnit.MINUTES) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  现在我们可以使用get方法读取值：\nDataObject dataObject = cache.get(key); assertNotNull(dataObject); assertEquals(\u0026quot;Data for \u0026quot; + key, dataObject.getData());  我们还可以使用getAll方法获取一组值：\nMap\u0026lt;String, DataObject\u0026gt; dataObjectMap = cache.getAll(Arrays.asList(\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;)); assertEquals(3, dataObjectMap.size());  值从传递给build方法的底层后端初始化Function中读取到，这样就可以使用缓存作为访问值的主要入口了。\n3.3、异步加载 此策略的工作原理与前一个相同，但是会异步执行操作并返回一个CompletableFuture来保存实际的值：\nAsyncLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumSize(100) .expireAfterWrite(1, TimeUnit.MINUTES) .buildAsync(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  我们可以以相同的方式使用get和getAll方法，考虑到它们的返回是CompletableFuture：\nString key = \u0026quot;A\u0026quot;; cache.get(key).thenAccept(dataObject -\u0026gt; { assertNotNull(dataObject); assertEquals(\u0026quot;Data for \u0026quot; + key, dataObject.getData()); }); cache.getAll(Arrays.asList(\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;)) .thenAccept(dataObjectMap -\u0026gt; assertEquals(3, dataObjectMap.size()));  CompletableFuture具有很多有用的API，您可以在本文中阅读更多相关信息。\n4、缓存值的清理 Caffeine有三种缓存值的清理策略：基于大小、基于时间和基于引用。\n4.1、基于大小的清理 这种类型的清理设计为在超出缓存配置的大小限制时发生清理。有两种获取大小的方法——计算缓存中的对象数，或者获取它们的权重。\n让我们看看如何计算缓存中的对象数。缓存初始化时，其大小为零：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumSize(1) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k)); assertEquals(0, cache.estimatedSize());  当我们添加一个值时，大小明显增加：\ncache.get(\u0026quot;A\u0026quot;); assertEquals(1, cache.estimatedSize());  我们可以将第二个值添加到缓存中，这会导致删除第一个值：\ncache.get(\u0026quot;B\u0026quot;); cache.cleanUp(); assertEquals(1, cache.estimatedSize());  值得一提的是，我们在获取缓存大小之前调用了cleanUp方法。这是因为缓存清理是异步执行的，该方法有助于等待清理完成。\n我们还可以传入一个weigher的Function来定义缓存大小的获取：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumWeight(10) .weigher((k,v) -\u0026gt; 5) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k)); assertEquals(0, cache.estimatedSize()); cache.get(\u0026quot;A\u0026quot;); assertEquals(1, cache.estimatedSize()); cache.get(\u0026quot;B\u0026quot;); assertEquals(2, cache.estimatedSize());  当权重超过 10 时，这些值将从缓存中删除：\ncache.get(\u0026quot;C\u0026quot;); cache.cleanUp(); assertEquals(2, cache.estimatedSize());  4.2、基于时间的清理 这种清理策略基于条目的过期时间，分为三种：\n 访问后过期——自上次读取或写入以来，条目在经过某段时间后过期 写入后过期——自上次写入以来，条目在经过某段时间后过期 自定义策略——由Expiry的实现来为每个条目单独计算到期时间  让我们使用expireAfterAccess方法配置访问后过期策略：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .expireAfterAccess(5, TimeUnit.MINUTES) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  要配置写入后过期策略，我们使用expireAfterWrite方法：\ncache = Caffeine.newBuilder() .expireAfterWrite(10, TimeUnit.SECONDS) .weakKeys() .weakValues() .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  要初始化自定义策略，我们需要实现Expiry接口：\ncache = Caffeine.newBuilder().expireAfter(new Expiry\u0026lt;String, DataObject\u0026gt;() { @Override public long expireAfterCreate( String key, DataObject value, long currentTime) { return value.getData().length() * 1000; } @Override public long expireAfterUpdate( String key, DataObject value, long currentTime, long currentDuration) { return currentDuration; } @Override public long expireAfterRead( String key, DataObject value, long currentTime, long currentDuration) { return currentDuration; } }).build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  4.3、基于引用的清理 我们可以配置我们的缓存，允许缓存的键或值或二者一起的垃圾收集。为此，我们需要为键和值配置WeakReference的使用，并且我们可以配置SoftReference仅用于值的垃圾收集。\nWeakReference的使用允许在没有对对象的任何强引用时对对象进行垃圾回收。SoftReference允许基于JVM的全局LRU（最近最少使用）策略对对象进行垃圾回收。可以在此处找到有关Java中引用的更多详细信息。\n我们使用Caffeine.weakKeys()、Caffeine.weakValues()和Caffeine.softValues()来启用每个选项：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .expireAfterWrite(10, TimeUnit.SECONDS) .weakKeys() .weakValues() .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k)); cache = Caffeine.newBuilder() .expireAfterWrite(10, TimeUnit.SECONDS) .softValues() .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  5、缓存刷新 可以将缓存配置为在定义的时间段后自动刷新条目。让我们看看如何使用refreshAfterWrite方法做到这一点：\nCaffeine.newBuilder() .refreshAfterWrite(1, TimeUnit.MINUTES) .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k));  在这里，我们应该明白expireAfter和refreshAfter的一个区别：当请求过期条目时，执行会阻塞，直到build函数计算出新值。但是如果该条目符合刷新条件，则缓存将返回一个旧值并异步重新加载该值。\n6、统计 Caffeine提供了一种记录缓存使用统计信息的方法：\nLoadingCache\u0026lt;String, DataObject\u0026gt; cache = Caffeine.newBuilder() .maximumSize(100) .recordStats() .build(k -\u0026gt; DataObject.get(\u0026quot;Data for \u0026quot; + k)); cache.get(\u0026quot;A\u0026quot;); cache.get(\u0026quot;A\u0026quot;); assertEquals(1, cache.stats().hitCount()); assertEquals(1, cache.stats().missCount());  我们还可以创建一个StatsCounter的实现作为参数来传入recordStats。每次与统计相关的更改，这个实现对象都将被调用。\n7、结论 在本文中，我们熟悉了Java的Caffeine缓存库。我们看到了如何配置和存入缓存，以及如何根据需要选择合适的过期或刷新策略。\n","date":"2021-07-06","permalink":"https://pinmost.com/post/java-caching-caffeine/","tags":["Java","Caching"],"title":"Caffeine缓存简单介绍"},{"content":"1、概述 Caffeine缓存是Java的高性能缓存库。在这个简短的教程中，我们将看到如何在Spring Boot中使用它。\n2、依赖 要开始使用Caffeine和Spring Boot，我们首先添加spring-boot-starter-cache和caffeine依赖项：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.ben-manes.caffeine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;caffeine\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  这些导入基本的Spring缓存支持以及Caffeine库。\n3、配置 现在我们需要在我们的Spring Boot应用程序中配置缓存。\n首先，我们创建一个caffeine的bean，用来控制缓存行为的主要配置，例如过期、缓存大小限制等：\n@Bean public Caffeine caffeineConfig() { return Caffeine.newBuilder().expireAfterWrite(60, TimeUnit.MINUTES); }  接下来，我们需要使用Spring CacheManager接口创建另一个bean。Caffeine提供了这个接口的实现，它需要我们上面创建的Caffeine对象：\n@Bean public CacheManager cacheManager(Caffeine caffeine) { CaffeineCacheManager caffeineCacheManager = new CaffeineCacheManager(); caffeineCacheManager.setCaffeine(caffeine); return caffeineCacheManager; }  最后，我们需要使用@EnableCaching注解在Spring Boot中启用缓存支持，这个注解可以添加到应用程序中的任何@Configuration类。\n4、例子 启用缓存并配置为使用Caffeine后，让我们看几个示例，说明如何在 Spring Boot 应用程序中使用缓存。\n在 Spring Boot 中使用缓存的主要方法是使用@Cacheable注解。此注解适用于 Spring bean（甚至整个类）的任何方法，它指示注册的缓存管理器将方法调用的结果存储在缓存中。\n一个典型的用法是在服务类中：\n@Service public class AddressService { @Cacheable public AddressDTO getAddress(long customerId) { // lookup and return result } }  使用不带参数的@Cacheable注解，Spring会为缓存和缓存的key使用默认名称。\n我们可以通过向注解添加一些参数来覆盖这两个做法：\n@Service public class AddressService { @Cacheable(value = \u0026quot;address_cache\u0026quot;, key = \u0026quot;customerId\u0026quot;) public AddressDTO getAddress(long customerId) { // lookup and return result } }  上面的示例告诉Spring使用名为address_cache的缓存和以customerId参数作为缓存key。\n最后，因为缓存管理器本身就是一个Spring bean，我们也可以将它自动装配到任何其他bean中并直接使用它：\n@Service public class AddressService { @Autowired CacheManager cacheManager; public AddressDTO getAddress(long customerId) { if(cacheManager.containsKey(customerId)) { return cacheManager.get(customerId); } // lookup address, cache result, and return it } }  5、结论 在本教程中，我们已经了解了如何配置Spring Boot以使用Caffeine缓存，以及如何在我们的应用程序中使用缓存的一些示例。\n","date":"2021-07-06","permalink":"https://pinmost.com/post/spring-boot-caffeine-cache/","tags":["Spring Boot","Caching"],"title":"在Spring Boot中使用Caffeine缓存"},{"content":"1、概述 Spring Data Redis提供了一种与Redis实例集成的简单方法。\n但是，在某些情况下，使用嵌入式服务器比使用真实服务器创建开发和测试环境更方便。\n因此，我们将学习如何设置和使用嵌入式Redis服务器。\n2、依赖 让我们首先添加必要的依赖项：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;it.ozimov\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;embedded-redis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.7.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  这个spring-boot-starter-test包含我们需要运行集成测试的各种依赖。\n此外，embedded-redis包含我们将使用的嵌入式服务器。\n3、设置 添加依赖项后，我们应该定义Redis服务器和我们的应用程序之间的连接设置。\n让我们首先创建一个类来保存我们的属性：\n@Configuration public class RedisProperties { private int redisPort; private String redisHost; public RedisProperties( @Value(\u0026quot;${spring.redis.port}\u0026quot;) int redisPort, @Value(\u0026quot;${spring.redis.host}\u0026quot;) String redisHost) { this.redisPort = redisPort; this.redisHost = redisHost; } // getters }  接下来，我们应该创建一个配置类来定义连接并使用我们的属性：\n@Configuration @EnableRedisRepositories public class RedisConfiguration { @Bean public LettuceConnectionFactory redisConnectionFactory( RedisProperties redisProperties) { return new LettuceConnectionFactory( redisProperties.getRedisHost(), redisProperties.getRedisPort()); } @Bean public RedisTemplate\u0026lt;?, ?\u0026gt; redisTemplate(LettuceConnectionFactory connectionFactory) { RedisTemplate\u0026lt;byte[], byte[]\u0026gt; template = new RedisTemplate\u0026lt;\u0026gt;(); template.setConnectionFactory(connectionFactory); return template; } }  配置非常简单。这样我们的嵌入式服务器可以在其他的端口上运行。\n4、嵌入式Redis服务器 现在，我们将配置嵌入式服务器并在我们的一项测试中使用它。\n首先，让我们在测试的资源目录（src/test/resources）中创建一个application.properties文件：\nspring.redis.host=localhost spring.redis.port=6370  之后，我们将创建一个@TestConfiguration注解的配置类：\n@TestConfiguration public class TestRedisConfiguration { private RedisServer redisServer; public TestRedisConfiguration(RedisProperties redisProperties) { this.redisServer = new RedisServer(redisProperties.getRedisPort()); } @PostConstruct public void postConstruct() { redisServer.start(); } @PreDestroy public void preDestroy() { redisServer.stop(); } }  当context上下文启动，服务器就跟着启动。它根据我们在属性中定义的端口运行在我们的机器上。有了它，我们现在可以在不停止实际Redis服务器的情况下运行测试了。\n理想情况下，我们希望在随机可用端口上启动它，但嵌入式Redis尚不具备此功能。我们现在可以做的是通过ServerSocket API 获取随机端口。\n此外，当上下文停止，服务器也跟着停止。\n服务器也可以由我们自己的可执行文件来提供：\nthis.redisServer = new RedisServer(\u0026quot;/path/redis\u0026quot;, redisProperties.getRedisPort());  此外，可执行文件可以按不同的操作系统来定义：\nRedisExecProvider customProvider = RedisExecProvider.defaultProvider() .override(OS.UNIX, \u0026quot;/path/unix/redis\u0026quot;) .override(OS.Windows, Architecture.x86_64, \u0026quot;/path/windows/redis\u0026quot;) .override(OS.MAC_OS_X, Architecture.x86_64, \u0026quot;/path/macosx/redis\u0026quot;); this.redisServer = new RedisServer(customProvider, redisProperties.getRedisPort());  最后，让我们创建一个使用TestRedisConfiguration类的测试吧：\n@RunWith(SpringRunner.class) @SpringBootTest(classes = TestRedisConfiguration.class) public class UserRepositoryIntegrationTest { @Autowired private UserRepository userRepository; @Test public void shouldSaveUser_toRedis() { UUID id = UUID.randomUUID(); User user = new User(id, \u0026quot;name\u0026quot;); User saved = userRepository.save(user); assertNotNull(saved); } }  这样用户保存就到了我们的嵌入式Redis服务器。\n此外，我们必须手动将TestRedisConfiguration添加到SpringBootTest。正如我们之前所说，服务器在测试之前启动并在测试之后停止。\n5、结论 嵌入式Redis服务器是在测试环境中替换实际服务器的完美工具。我们已经看到了如何配置它以及如何在我们的测试中使用它。\n","date":"2021-07-05","permalink":"https://pinmost.com/post/spring-embedded-redis/","tags":["Spring Boot","Testing","Redis"],"title":"嵌入式Redis服务器在Spring Boot测试中的使用"},{"content":"1、简介 在这个简短的教程中，我们将看看如何将Redis配置为Spring Boot缓存的数据存储。\n2、依赖 首先，让我们在pom.xml中添加spring-boot-starter-cache和spring-boot-starter-data-redis组件：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  这些添加了缓存支持并引入了所有必需的依赖项。\n3、配置 通过添加上述依赖项和@EnableCaching注解，Spring Boot 将使用默认缓存配置自动配置一个RedisCacheManager。但是，我们可以在缓存管理器初始化之前以几种有用的方式修改此配置。\n首先，让我们创建一个RedisCacheConfiguration bean：\n@Bean public RedisCacheConfiguration cacheConfiguration() { return RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(60)) .disableCachingNullValues() .serializeValuesWith(SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())); }  这使我们可以更好地控制默认配置——例如，我们可以设置所需的生存时间 (TTL) 值并自定义用于动态缓存创建的默认序列化策略。\n接下来，为了完全控制缓存设置，让我们注册我们自己的RedisCacheManagerBuilderCustomizer bean：\n@Bean public RedisCacheManagerBuilderCustomizer redisCacheManagerBuilderCustomizer() { return (builder) -\u0026gt; builder .withCacheConfiguration(\u0026quot;itemCache\u0026quot;, RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofMinutes(10))) .withCacheConfiguration(\u0026quot;customerCache\u0026quot;, RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofMinutes(5))); }  在这里，我们使用RedisCacheManagerBuilder和RedisCacheConfiguration分别为itemCache和customerCache配置了10分钟和5分钟的TTL值。这有助于在每个缓存的基础上进一步微调缓存行为，包括空值、键前缀和二进制序列化。\n值得一提的是，Redis实例的默认连接详细信息是localhost:6379。Redis配置可用于进一步调整更底层的连接细节以及主机和端口。\n4、例子 在我们的示例中，我们有一个ItemService组件，用于从数据库中检索项目信息。实际上，假设这是一个潜在的代价高昂的操作，是一个很好的使用缓存场景。\n首先，让我们使用嵌入式Redis服务器为该组件创建集成测试：\n@Import({ CacheConfig.class, ItemService.class}) @ExtendWith(SpringExtension.class) @EnableCaching @ImportAutoConfiguration(classes = { CacheAutoConfiguration.class, RedisAutoConfiguration.class }) class ItemServiceCachingIntegrationTest { @MockBean private ItemRepository mockItemRepository; @Autowired private ItemService itemService; @Autowired private CacheManager cacheManager; @Test void givenRedisCaching_whenFindItemById_thenItemReturnedFromCache() { Item anItem = new Item(AN_ID, A_DESCRIPTION); given(mockItemRepository.findById(AN_ID)) .willReturn(Optional.of(anItem)); Item itemCacheMiss = itemService.getItemForId(AN_ID); Item itemCacheHit = itemService.getItemForId(AN_ID); assertThat(itemCacheMiss).isEqualTo(anItem); assertThat(itemCacheHit).isEqualTo(anItem); verify(mockItemRepository, times(1)).findById(AN_ID); assertThat(itemFromCache()).isEqualTo(anItem); } }  在这里，我们为缓存行为创建一个测试切面并调用getItemForId两次。第一次调用应该从存储库中获取结果，但第二次调用应该从缓存中返回结果而不调用存储库。\n最后，让我们使用Spring的@Cacheable注解启用缓存行为：\n@Cacheable(value = \u0026quot;itemCache\u0026quot;) public Item getItemForId(String id) { return itemRepository.findById(id) .orElseThrow(RuntimeException::new); }  这就应用了缓存逻辑，同时依赖于我们之前配置的Redis缓存的基础架构。有关控制Spring缓存对象的属性和行为（包括数据更新和清除）的更多详细信息，可以参见Spring缓存指南文章。\n5、结论 在本文章中，我们已经看到了如何使用Redis进行Spring Boot缓存。\n","date":"2021-07-05","permalink":"https://pinmost.com/post/spring-boot-redis-cache/","tags":["Spring Data","Caching","Redis"],"title":"如何使用Redis作为Spring Boot缓存"}]